//////////////////////////////////////////////////////////////////
float Cone(vec3 Local, float BaseRadius, float ConeHeight) {
    float Slope = -ConeHeight / BaseRadius,
        Ratio = sqrt(1.0/(Slope * Slope + 1.0));
    vec2 Test = vec2(abs(length(Local.xy)), Local.z);
    float Vertical = (Slope * Test.x + ConeHeight - Test.y), 
        Perpendicular = Vertical * Ratio;
    
    return -min(Perpendicular, Test.y); //?
}

float Union(float LHS, float RHS) {
    return min(LHS, RHS);
}

float SceneSDF(vec3 View) {
    float Shape = Cone(View - vec3(0.0, 10.0, -1.0), 1.0, 2.0);
    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(-2.0, 10.0, -1.0), 1.0, 2.0));
    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(2.0, 10.0, -1.0), 1.0, 2.0));
    
    return Shape;
}
////////////////////////////////////////////////////////////////////

vec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV) {
    float Aspect = Resolution.y / Resolution.x;
    vec2 NDC = FragCoord / iResolution.xy * 2.0 - 1.0,
        Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;
    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;
    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));
    
    return RayDir;
}

void mainImage( out vec4 FragColor, vec2 FragCoord ) {
    vec3 Position = vec3(0);
        
    vec3 RayDir = GetRayDir(FragCoord.xy, iResolution.xy, 60.0);
    float TravelStart = SceneSDF(Position),
        Traveled = TravelStart;
    bool bHit = false;
    
    //while (!bHit || Traveled < TravelStart) { //NO <= ! crash
    while (true) {
    	if (!(bHit || Traveled >= TravelStart)) {
            Position = RayDir * Traveled;
            float Dist = SceneSDF(Position); //magia
            Traveled += Dist;
            bHit = Dist < 1e-3;           
        }
    } //magia: TravelStart = punto mas cercano para cada rayo
      
    FragColor = vec4(vec3(int(bHit)), 1);
}
