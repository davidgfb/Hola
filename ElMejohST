//////////////////////////////////////////////////////////////////
float Cone(vec3 Local, float BaseRadius, float ConeHeight) {
    float Slope = -ConeHeight / BaseRadius,
        Ratio = sqrt(1.0/(Slope * Slope + 1.0));
    vec2 Test = vec2(abs(length(Local.xy)), Local.z);
    float Vertical = (Slope * Test.x + ConeHeight - Test.y), 
        Perpendicular = Vertical * Ratio;
    
    return -min(Perpendicular, Test.y); //?
}

float Union(float LHS, float RHS) {
    return min(LHS, RHS);
}

float SceneSDF(vec3 View) {
    float Shape = Cone(View - vec3(0.0, 10.0, -1.0), 1.0, 2.0);
    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(-2.0, 10.0, -1.0), 1.0, 2.0));
    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(2.0, 10.0, -1.0), 1.0, 2.0));
    
    return Shape;
}
////////////////////////////////////////////////////////////////////

vec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV) {
    float Aspect = Resolution.y / Resolution.x;
    vec2 NDC = FragCoord / iResolution.xy * 2.0 - 1.0,
        Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;
    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;
    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));
    
    return RayDir;
}

bool RayMarch(vec3 RayDir, float TravelStart, float TravelEnd, out vec3 Position) {
    float Traveled = TravelStart;
    bool bHit = false;
    
    for (int i=0; i<100; ++i) {
    	Position = RayDir * Traveled;
        float Dist = SceneSDF(Position); //magia
		Traveled += Dist;
        bHit = Dist < 1e-3;
        
        if (bHit || Traveled >= TravelEnd) {
            break;
        }
    }
    
    return bHit;
}

void mainImage( out vec4 FragColor, vec2 FragCoord ) {
    vec3 Position = vec3(0);
    bool bHit = RayMarch(GetRayDir(FragCoord.xy, iResolution.xy, 60.0), 1.0, 1000.0, Position), //magia
        bOutline = fwidth(float(bHit)) > 0.0;
    
    FragColor = vec4(vec3(int(bHit)), 1);
}
